/**
 * 認証プロバイダ
 *
 * FSD: shared/lib/providers
 * 設計書: 02_system-design.md - 9.2 認証セッション永続化
 *
 * 役割:
 * - アプリ起動時のセッション復元（Supabaseが自動で行う）
 * - Supabase Authイベントの監視
 * - 認証状態変更時のZustand Store更新
 * - ゲストモード対応（認証なしでも閲覧可能）
 *
 * セッション管理:
 * - Supabaseクライアントが SecureStorageAdapter を使用して自動管理
 * - トークンの保存/復元/リフレッシュはすべてSupabaseが処理
 */

import React, { useEffect, useState, useCallback, useRef } from 'react';
import { AppState, View } from 'react-native';
import { supabase } from '@/shared/api/supabase/client';
import { upsertUserToSupabase } from '@/shared/api/supabase/auth';
import { getUserById as getUserByIdFromSupabase } from '@/shared/api/supabase/users';
import { completeOnboarding } from '@/shared/api/supabase/users/update-profile';
import {
  getCurrentTermsVersions,
  recordTermsAgreement,
  getUserLatestAgreement,
} from '@/shared/api/supabase/terms';
import {
  loginToRevenueCat,
  logoutFromRevenueCat,
  isPremiumActive,
  addSubscriptionListener,
  removeSubscriptionListener,
  type CustomerInfo,
} from '@/shared/api/revenuecat';
import { cacheUserToSQLite } from '@/shared/lib/cache';
import { setSentryUser } from '@/shared/lib/init/sentry';
import { identifyUser as identifyPostHogUser, resetUser as resetPostHogUser } from '@/shared/lib/init/posthog';
import { log } from '@/shared/config/logger';
import { clearAllQueries } from '@/shared/api/query-client';
import { clearPersistedCache } from '@/shared/lib/cache';
import { useUserStore } from '@/entities/user/model';
import { useSubscriptionStore } from '@/entities/subscription';
import { useAppSettingsStore, useTutorialStore } from '@/shared/lib/store';
import { syncLocalPreferencesToServer } from '@/entities/user/api/use-user-preferences';
import { getCurrentLocale } from '@/shared/lib/i18n';
import { ProfileSetupStep, DemographicsStep, CategoryPreferenceStep, CompletionStep } from '@/pages/onboarding';
import type { User } from '@/entities/user/model';

interface AuthProviderProps {
  children: React.ReactNode;
}

/**
 * プロフィール設定が完了しているかチェック
 * ユーザー名が自動生成パターン（user_{id先頭8文字}）と異なれば完了
 */
function hasProfileSetupCompleted(user: User | null): boolean {
  if (!user) return false;
  const autoGeneratedPattern = `user_${user.id.slice(0, 8)}`;
  return user.username !== autoGeneratedPattern;
}

/**
 * デモグラフィック情報が入力済みかチェック
 * gender または age_group が入力されていれば完了とみなす
 */
function hasDemographicsCompleted(user: User | null): boolean {
  if (!user) return false;
  // gender または age_group どちらかが設定されていれば完了とみなす
  return user.gender !== null || user.age_group !== null;
}

/**
 * ログイン時にローカルの同意情報をサーバーに同期
 * 未ログイン時にオンボーディングで同意した内容をサーバーに記録
 */
async function syncTermsAgreementToServer(userId: string): Promise<void> {
  try {
    // ローカルの同意バージョンを取得
    const { agreedTermsVersion, agreedPrivacyVersion } = useAppSettingsStore.getState();

    if (!agreedTermsVersion || !agreedPrivacyVersion) {
      log.debug('[AuthProvider] ローカルに同意情報なし、同期スキップ');
      return;
    }

    // サーバーの同意情報を確認
    const serverAgreement = await getUserLatestAgreement(userId);

    // すでにサーバーに同じバージョンの同意が記録されていればスキップ
    if (
      serverAgreement &&
      serverAgreement.terms_version === agreedTermsVersion &&
      serverAgreement.privacy_version === agreedPrivacyVersion
    ) {
      log.debug('[AuthProvider] サーバーに同意情報あり、同期スキップ');
      return;
    }

    // サーバーから現在の規約バージョンIDを取得
    const currentTerms = await getCurrentTermsVersions();
    if (!currentTerms.termsOfService || !currentTerms.privacyPolicy) {
      log.warn('[AuthProvider] サーバーに規約が設定されていません');
      return;
    }

    // ローカルの同意バージョンとサーバーの規約バージョンが一致するか確認
    if (
      currentTerms.termsOfService.version !== agreedTermsVersion ||
      currentTerms.privacyPolicy.version !== agreedPrivacyVersion
    ) {
      log.debug('[AuthProvider] ローカルとサーバーの規約バージョンが異なる、同期スキップ');
      return;
    }

    // サーバーに同意を記録
    await recordTermsAgreement(
      userId,
      currentTerms.termsOfService.id,
      currentTerms.privacyPolicy.id
    );

    log.info('[AuthProvider] 同意情報をサーバーに同期しました');
  } catch (err) {
    log.error('[AuthProvider] 同意情報の同期に失敗:', err);
    // 失敗してもアプリは続行
  }
}

/**
 * 認証プロバイダ
 *
 * アプリ起動時に以下の処理を行う：
 * 1. Supabaseが自動でSecureStoreからセッション復元
 * 2. 復元失敗 → ゲストモードで起動（認証なしでも閲覧可能）
 * 3. Supabase Authイベントを監視してZustand Storeを同期
 */
export function AuthProvider({ children }: AuthProviderProps) {
  const [isInitializing, setIsInitializing] = useState(true);
  const [showProfileSetup, setShowProfileSetup] = useState(false);
  const [showDemographics, setShowDemographics] = useState(false);
  const [showCategories, setShowCategories] = useState(false);
  const [showCompletion, setShowCompletion] = useState(false);
  const { setUser, setAuthState } = useUserStore();
  const { setSubscriptionStatus, reset: resetSubscription } = useSubscriptionStore();

  // 一度表示したステップはマウントし続ける（戻った時にstateを保持するため）
  const mountedDemographics = useRef(false);
  const mountedCategories = useRef(false);

  // プロフィール設定完了時のハンドラ
  const handleProfileSetupComplete = useCallback(() => {
    log.debug('[AuthProvider] プロフィール設定完了');
    setShowProfileSetup(false);
    // プロフィール設定後、デモグラフィックが未完了なら表示
    const currentUser = useUserStore.getState().user;
    if (!hasDemographicsCompleted(currentUser)) {
      log.debug('[AuthProvider] デモグラフィック未入力、入力画面を表示');
      mountedDemographics.current = true;
      setShowDemographics(true);
    }
  }, []);

  // デモグラフィック完了時のハンドラ（保存はDemographicsStep内で行う）
  const handleDemographicsComplete = useCallback(() => {
    log.debug('[AuthProvider] デモグラフィック入力完了');
    setShowDemographics(false);
    mountedCategories.current = true;
    setShowCategories(true);
  }, []);

  // デモグラフィック → プロフィールに戻る
  const handleDemographicsBack = useCallback(() => {
    log.debug('[AuthProvider] デモグラフィック → プロフィール設定に戻る');
    setShowDemographics(false);
    setShowProfileSetup(true);
  }, []);

  // カテゴリ選択完了時のハンドラ
  const handleCategoriesComplete = useCallback(() => {
    log.debug('[AuthProvider] カテゴリ選択完了');
    setShowCategories(false);
    setShowCompletion(true);
  }, []);

  // カテゴリ → デモグラフィックに戻る
  const handleCategoriesBack = useCallback(() => {
    log.debug('[AuthProvider] カテゴリ → デモグラフィックに戻る');
    setShowCategories(false);
    setShowDemographics(true);
  }, []);

  // 完了画面のハンドラ
  const handleCompletionComplete = useCallback(async () => {
    log.debug('[AuthProvider] オンボーディング完了');
    // DBにオンボーディング完了を記録
    const currentUser = useUserStore.getState().user;
    if (currentUser) {
      try {
        const updatedUser = await completeOnboarding(currentUser.id);
        setUser(updatedUser as User);
      } catch (err) {
        log.error('[AuthProvider] オンボーディング完了の記録に失敗:', err);
      }
    }
    setShowCompletion(false);
    // チュートリアル（コーチマーク）を開始
    useTutorialStore.getState().requestStartTutorial();
  }, [setUser]);

  useEffect(() => {
    let isMounted = true;
    let subscription: any = null;
    let appStateSubscription: ReturnType<typeof AppState.addEventListener> | null = null;
    let isListenerRegistered = false;

    // RevenueCat CustomerInfo更新リスナー
    const customerInfoListener = (customerInfo: CustomerInfo) => {
      if (!isMounted) return;
      const isPremium = isPremiumActive(customerInfo);
      log.debug('[AuthProvider] RevenueCat CustomerInfo更新:', isPremium ? 'Premium' : 'Free');
      setSubscriptionStatus(isPremium, customerInfo);
    };

    // リスナー登録（多重登録を防止）
    const registerListenerIfNeeded = () => {
      if (isListenerRegistered) return;
      addSubscriptionListener(customerInfoListener);
      isListenerRegistered = true;
    };

    // AppStateリスナー（フォアグラウンド復帰時にサブスクリプション状態をリフレッシュ）
    const setupAppStateListener = () => {
      if (appStateSubscription) return;
      appStateSubscription = AppState.addEventListener('change', (nextAppState) => {
        if (nextAppState === 'active') {
          log.debug('[AuthProvider] フォアグラウンド復帰、サブスクリプション状態をリフレッシュ');
          useSubscriptionStore.getState().refreshSubscriptionStatus();
        }
      });
    };

    async function initializeAuth() {
      try {
        log.debug('[AuthProvider] 認証初期化開始');

        // Supabaseが自動でSecureStoreからセッションを復元する
        // getSession()を呼ぶことで復元されたセッションを取得
        const { data: { session } } = await supabase.auth.getSession();

        if (session?.user && isMounted) {
          // セッション復元成功
          log.info('[AuthProvider] セッション復元成功:', session.user.id);

          // Supabase public.users にupsert（外部キー制約を満たすため）
          await upsertUserToSupabase(session.user);

          // SQLiteにもキャッシュとして同期
          await cacheUserToSQLite(session.user);

          // Supabaseから最新のユーザー情報を取得してストアに保存
          // （プロフィール更新後も最新データが反映されるようにするため）
          const userData = await getUserByIdFromSupabase(session.user.id);
          if (userData && isMounted) {
            setUser(userData as User);
            setAuthState('authenticated');
            // Sentryにユーザー情報を設定
            setSentryUser({ id: userData.id, username: userData.username });
            // PostHogにユーザーを識別
            identifyPostHogUser(userData.id, { username: userData.username });

            // セッション復元時もオンボーディング未完了チェック
            // （オンボーディング中にアプリが落ちた場合の復帰用）
            // onboarding_completed_at が設定済みならオンボーディング不要
            if (!(userData as User).onboarding_completed_at) {
              if (!hasProfileSetupCompleted(userData as User)) {
                log.debug('[AuthProvider] セッション復元: プロフィール未設定、設定画面を表示');
                setShowProfileSetup(true);
              } else if (!hasDemographicsCompleted(userData as User)) {
                log.debug('[AuthProvider] セッション復元: デモグラフィック未入力、入力画面を表示');
                mountedDemographics.current = true;
                setShowDemographics(true);
              }
            }
          }

          // RevenueCatにログインしてサブスクリプション状態を取得
          try {
            const customerInfo = await loginToRevenueCat(session.user.id);
            const isPremium = isPremiumActive(customerInfo);
            if (isMounted) {
              setSubscriptionStatus(isPremium, customerInfo);
              // リスナーを設定してサブスクリプション状態のリアルタイム同期を開始
              addSubscriptionListener(customerInfoListener);
              setupAppStateListener();
            }
          } catch (err) {
            log.warn('[AuthProvider] RevenueCatログインエラー（続行）:', err);
          }

          // ユーザー設定（locale等）をサーバーに同期（セッション復元時）
          await syncLocalPreferencesToServer(getCurrentLocale());
        } else {
          // セッション復元失敗 → ゲストモード（認証なしでも閲覧可能）
          log.debug('[AuthProvider] セッションなし、ゲストモードで起動');
          if (isMounted) {
            setUser(null);
            setAuthState('unauthenticated');
          }
        }

        // 認証完了後にSupabase Authイベントを監視開始
        if (isMounted) {
          const { data } = supabase.auth.onAuthStateChange((event, session) => {
            log.debug('[AuthProvider] Auth event:', event);

            // 非同期処理はコールバック外で実行（setSessionのブロッキングを防ぐ）
            if (event === 'SIGNED_IN' && session?.user) {
              // サインイン時（Email/Password、OAuth）
              const user = session.user;
              (async () => {
                try {
                  // Supabase public.users にupsert（外部キー制約を満たすため）
                  await upsertUserToSupabase(user);

                  // SQLiteにもキャッシュとして同期
                  await cacheUserToSQLite(user);

                  // Supabaseから最新のユーザー情報を取得してストアに保存
                  const userData = await getUserByIdFromSupabase(user.id);
                  if (userData && isMounted) {
                    setUser(userData as User);
                    setAuthState('authenticated');
                    // Sentryにユーザー情報を設定
                    setSentryUser({ id: userData.id, username: userData.username });
                    // PostHogにユーザーを識別
                    identifyPostHogUser(userData.id, { username: userData.username });

                    // 初回サインアップ時のみオンボーディング画面を表示
                    // onboarding_completed_at が設定済みならオンボーディング不要
                    if (!(userData as User).onboarding_completed_at) {
                      if (!hasProfileSetupCompleted(userData as User)) {
                        log.debug('[AuthProvider] プロフィール未設定、設定画面を表示');
                        setShowProfileSetup(true);
                      } else if (!hasDemographicsCompleted(userData as User)) {
                        log.debug('[AuthProvider] デモグラフィック未入力、入力画面を表示');
                        mountedDemographics.current = true;
                        setShowDemographics(true);
                      }
                    }
                  }

                  // RevenueCatにログインしてサブスクリプション状態を取得
                  try {
                    const customerInfo = await loginToRevenueCat(user.id);
                    const isPremium = isPremiumActive(customerInfo);
                    if (isMounted) {
                      setSubscriptionStatus(isPremium, customerInfo);
                      // リスナーを設定してサブスクリプション状態のリアルタイム同期を開始
                      registerListenerIfNeeded();
                      setupAppStateListener();
                    }
                  } catch (rcErr) {
                    log.warn('[AuthProvider] RevenueCatログインエラー（続行）:', rcErr);
                  }

                  // ローカルの同意情報をサーバーに同期
                  await syncTermsAgreementToServer(user.id);

                  // ユーザー設定（locale等）をサーバーに同期
                  await syncLocalPreferencesToServer(getCurrentLocale());
                } catch (err) {
                  log.error('[AuthProvider] SIGNED_IN処理エラー:', err);
                }
              })();
            } else if (event === 'SIGNED_OUT') {
              // サインアウト時
              (async () => {
                // リスナーをクリーンアップ
                removeSubscriptionListener(customerInfoListener);
                isListenerRegistered = false;
                if (appStateSubscription) {
                  appStateSubscription.remove();
                  appStateSubscription = null;
                }

                // RevenueCatからログアウト
                try {
                  await logoutFromRevenueCat();
                } catch (rcErr) {
                  log.warn('[AuthProvider] RevenueCatログアウトエラー:', rcErr);
                }

                if (isMounted) {
                  setUser(null);
                  setAuthState('unauthenticated');
                  resetSubscription();
                  // 認証済みキャッシュの残留を防止
                  clearAllQueries();
                  // AsyncStorageに永続化されたキャッシュもクリア
                  clearPersistedCache().catch((err) =>
                    log.warn('[AuthProvider] 永続化キャッシュクリアエラー:', err)
                  );
                  // Sentryからユーザー情報をクリア
                  setSentryUser(null);
                  // PostHogのユーザーをリセット
                  resetPostHogUser();
                }
              })();
            }
            // TOKEN_REFRESHED: Supabaseが自動でSecureStoreに保存するので何もしない
          });
          subscription = data.subscription;
        }
      } catch (err) {
        log.error('[AuthProvider] 認証初期化エラー:', err);
        // エラーが発生してもゲストモードで続行
        if (isMounted) {
          setUser(null);
          setAuthState('unauthenticated');
        }
      } finally {
        if (isMounted) {
          setIsInitializing(false);
        }
      }
    }

    initializeAuth();

    // クリーンアップ
    return () => {
      isMounted = false;
      if (subscription) {
        subscription.unsubscribe();
      }
      removeSubscriptionListener(customerInfoListener);
      if (appStateSubscription) {
        appStateSubscription.remove();
        appStateSubscription = null;
      }
    };
  }, []); // Zustandのsetterは安定した参照なので依存配列に含めない

  // 初期化中のみローディング表示
  if (isInitializing) {
    return null; // または軽量なスプラッシュ画面
  }

  // オンボーディング中はステップを表示（display:'none'で非表示にしてstate保持）
  const isOnboarding = showProfileSetup || showDemographics || showCategories || showCompletion;

  if (isOnboarding) {
    return (
      <>
        <View style={{ flex: showProfileSetup ? 1 : 0, display: showProfileSetup ? 'flex' : 'none' }}>
          <ProfileSetupStep onComplete={handleProfileSetupComplete} />
        </View>
        {mountedDemographics.current && (
          <View style={{ flex: showDemographics ? 1 : 0, display: showDemographics ? 'flex' : 'none' }}>
            <DemographicsStep onComplete={handleDemographicsComplete} onBack={handleDemographicsBack} />
          </View>
        )}
        {mountedCategories.current && (
          <View style={{ flex: showCategories ? 1 : 0, display: showCategories ? 'flex' : 'none' }}>
            <CategoryPreferenceStep onComplete={handleCategoriesComplete} onBack={handleCategoriesBack} />
          </View>
        )}
        {showCompletion && (
          <CompletionStep onComplete={handleCompletionComplete} />
        )}
      </>
    );
  }

  return <>{children}</>;
}
