# Machikore (街コレ) プロジェクト

## アーキテクチャ

このプロジェクトは **Feature-Sliced Design (FSD)** アーキテクチャを採用しています。

### FSD 階層構造

```
src/
├── app/           # アプリケーション初期化、プロバイダー、グローバル設定
├── pages/         # ルーティング可能な画面全体（複数のWidgetを組み合わせる）
├── widgets/       # 複数のFeatureやEntityを組み合わせた複合コンポーネント
├── features/      # ユーザーのアクション・インタラクション（フィルター、検索など）
├── entities/      # ビジネスエンティティ（User, Post, Machi など）
├── shared/        # 共有ライブラリ、UI コンポーネント、ユーティリティ
```

### FSD の原則

1. **単方向依存**: 下位層は上位層に依存してはいけない
   - `shared` ← `entities` ← `features` ← `widgets` ← `pages` ← `app`

2. **Pages**: ルーティング可能な画面。Widgetの組み合わせのみ
3. **Widgets**: 複合的なUI。再利用可能なコンポーネント単位
4. **Features**: ユーザーアクション・機能（検索、フィルター、認証など）
5. **Entities**: ビジネスロジックとデータ（API、hooks、型定義）
6. **Shared**: プロジェクト全体で使う共通コード

### 開発時の注意

- 新しいコンポーネントを作成する際は、必ずFSDの階層構造に従う
- Pages層にはビジネスロジックを書かず、Widgetの組み合わせのみ
- Widget層には複数のFeatureやEntityを組み合わせる
- Feature層には具体的なユーザーアクションを実装
- Entity層にはビジネスエンティティとそのデータ取得ロジック

## スタイリング

- **NativeWind（Tailwind CSS for React Native）** を使用
- スタイリングは `className` で Tailwind クラスを使用し、`StyleSheet.create()` は使わない
- 動的な値（width, height など）のみ `style` プロパティを使用

## データストレージ方針

本番運用に備え、以下の方針でデータを管理します：

### Supabase = メインのデータストア（信頼できる唯一の情報源）
- ユーザー、マップ、スポット等のすべてのデータはSupabaseに保存
- データの作成・更新はSupabaseに直接書き込む
- 認証時に `public.users` テーブルにupsert（外部キー制約を満たすため）

### SQLite = キャッシュ/オフライン対応用
- Supabaseから取得したデータをローカルにキャッシュ
- オフライン時の読み取り用
- 将来的に同期キューでオフライン書き込みに対応予定

### データフロー
1. **認証時**: Supabase Auth → `public.users` にupsert → SQLiteにキャッシュ
2. **データ取得**: Supabaseから取得 → SQLiteにキャッシュ
3. **データ作成/更新**: Supabaseに保存 → 成功したらSQLiteにも保存

## Supabase マイグレーション

**重要: `npx supabase db push` コマンドは絶対に使用しないでください。**

マイグレーションファイルとSupabaseのDBの構造が異なる可能性があり、このコマンドを実行するとSupabaseが上書きされてしまいます。Supabaseへのマイグレーション適用はユーザーが手動で行います。

## Git コミットメッセージ

**コミットメッセージは日本語で記述してください。**

## 開発時のコミュニケーション

- **判断に迷った場合は必ずユーザーに確認する**
- 複数の実装方法がある場合、勝手に決めずに選択肢を提示して確認を取る
- 既存コードに大きな変更を加える場合は、事前に方針を確認する

## Web検索時の注意

- 技術情報を検索する際は、まず現在の年（2025年）で検索する
- 2025年の情報が見つからない場合は、2024年で再検索する

## テストの方針

- **テストの目的はバグを発見して実装を修正すること**
- テストが失敗した場合、実装にバグがないか検討し、必要なら実装を修正する
- 実装に合わせてテストを書き換えるのは本末転倒（テストをパスさせるための実装変更は不可）
- テストは「期待される正しい振る舞い」を記述し、実装がそれに従うべき
