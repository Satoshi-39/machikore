/**
 * Style Dictionary Configuration
 *
 * デザイントークンを各プラットフォーム用に変換する設定
 * - Mobile: TypeScript + Tailwind theme object
 * - Web: CSS Variables
 * - Storybook: JSON (ドキュメント用)
 *
 * CTI命名規則（Category > Type > Item > State）に対応
 */

import StyleDictionary from 'style-dictionary';
import { readFileSync } from 'fs';
import { resolve, dirname } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));

// ============================================================
// 共通ユーティリティ関数
// ============================================================

/**
 * JSONファイルを直接読み込んでマージする
 */
const loadTokens = () => {
  const load = (path) => JSON.parse(readFileSync(resolve(__dirname, path), 'utf-8'));

  return {
    primitive: {
      ...load('tokens/primitive/color.json'),
      ...load('tokens/primitive/spacing.json'),
      ...load('tokens/primitive/typography.json'),
      ...load('tokens/primitive/shadow.json'),
      ...load('tokens/primitive/motion.json'),
    },
    semanticLight: load('tokens/semantic/color.json'),
    semanticDark: load('tokens/semantic/color-dark.json'),
    semanticAction: load('tokens/semantic/action.json'),
    component: {
      ...load('tokens/component/spot-pin.json').component,
      ...load('tokens/component/ranking.json').component,
      ...load('tokens/component/transport.json').component,
      ...load('tokens/component/oauth.json').component,
      ...load('tokens/component/map-label.json').component,
      ...load('tokens/component/editor.json').component,
    },
  };
};

/**
 * トークン参照を解決する
 * 例: "{color.gray.900}" → "#111827"
 */
const resolveReference = (value, primitiveColor) => {
  if (typeof value !== 'string' || !value.startsWith('{')) return value;

  const refPath = value.slice(1, -1).split('.');
  let resolved = primitiveColor;
  const startIndex = refPath[0] === 'color' ? 1 : 0;

  for (let i = startIndex; i < refPath.length; i++) {
    resolved = resolved?.[refPath[i]];
    if (!resolved) return value;
  }

  return typeof resolved === 'object' && resolved.value ? resolved.value : resolved;
};

/**
 * HEXをRGB値に変換（NativeWind用）
 */
const hexToRgb = (hex) => {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result
    ? `${parseInt(result[1], 16)} ${parseInt(result[2], 16)} ${parseInt(result[3], 16)}`
    : '0 0 0';
};

/**
 * ネストされたトークンオブジェクトをフラット化して構築
 * @param obj - ソースオブジェクト
 * @param resolver - 値を解決する関数（省略時はそのまま）
 */
const buildNestedObject = (obj, resolver = (v) => v) => {
  const result = {};

  const process = (source, target, prefix = []) => {
    for (const [key, val] of Object.entries(source)) {
      if (val?.value !== undefined) {
        let current = target;
        for (const p of prefix) {
          current = current[p] ??= {};
        }
        current[key] = resolver(val.value);
      } else if (val && typeof val === 'object') {
        process(val, target, [...prefix, key]);
      }
    }
  };

  process(obj, result);
  return result;
};

/**
 * 単純なキー:値オブジェクトを構築（spacing, radius等）
 */
const buildFlatObject = (obj) => {
  const result = {};
  for (const [key, val] of Object.entries(obj || {})) {
    if (val?.value !== undefined) result[key] = val.value;
  }
  return result;
};

// ============================================================
// フォーマット定義
// ============================================================

// Mobile用 Tailwind theme format
StyleDictionary.registerFormat({
  name: 'javascript/tailwind-theme',
  format: () => {
    const tokens = loadTokens();
    const resolve = (v) => resolveReference(v, tokens.primitive.color);

    const primitive = buildNestedObject(tokens.primitive.color);
    const light = buildNestedObject(tokens.semanticLight.color, resolve);
    const dark = buildNestedObject(tokens.semanticDark.color, resolve);
    const component = buildNestedObject(tokens.component, resolve);
    const action = buildNestedObject(tokens.semanticAction, resolve);

    // light/darkにcomponent/actionカラーをマージ
    Object.assign(light, component, action);
    Object.assign(dark, component, action);

    // Typography
    const fontFamily = buildFlatObject(tokens.primitive.font?.family);
    const fontSize = buildFlatObject(tokens.primitive.font?.size);
    const fontWeight = buildFlatObject(tokens.primitive.font?.weight);
    const lineHeight = buildFlatObject(tokens.primitive.font?.lineHeight);
    const letterSpacing = buildFlatObject(tokens.primitive.font?.letterSpacing);

    // Layout
    const spacing = buildFlatObject(tokens.primitive.spacing);
    const borderRadius = buildFlatObject(tokens.primitive.radius);

    const fmt = (obj) => JSON.stringify(obj, null, 2).replace(/\n/g, '\n    ');

    return `/**
 * Tailwind Theme - Auto-generated by Style Dictionary
 * Do not edit directly
 */

module.exports = {
  colors: {
    primitive: ${fmt(primitive)},
    light: ${fmt(light)},
    dark: ${fmt(dark)}
  },
  fontFamily: ${fmt(fontFamily)},
  fontSize: ${fmt(fontSize)},
  fontWeight: ${fmt(fontWeight)},
  lineHeight: ${fmt(lineHeight)},
  letterSpacing: ${fmt(letterSpacing)},
  spacing: ${fmt(spacing)},
  borderRadius: ${fmt(borderRadius)}
};
`;
  },
});

// CSS Variables format (Web用)
StyleDictionary.registerFormat({
  name: 'css/variables-web',
  format: () => {
    const tokens = loadTokens();
    const resolve = (v) => resolveReference(v, tokens.primitive.color);

    const processVars = (obj, prefix = '') => {
      const vars = [];
      const process = (source, currentPrefix) => {
        for (const [key, val] of Object.entries(source)) {
          if (val?.value !== undefined) {
            const varName = currentPrefix ? `${currentPrefix}-${key}` : key;
            vars.push(`  --${varName}: ${resolve(val.value)};`);
          } else if (val && typeof val === 'object') {
            process(val, currentPrefix ? `${currentPrefix}-${key}` : key);
          }
        }
      };
      process(obj, prefix);
      return vars.sort();
    };

    const lightVars = processVars(tokens.semanticLight.color);
    const darkVars = processVars(tokens.semanticDark.color);
    const componentVars = processVars(tokens.component, 'component');

    return `/**
 * CSS Variables - Auto-generated by Style Dictionary
 * Do not edit directly
 */

@layer base {
  :root {
${[...lightVars, ...componentVars].join('\n')}
  }

  .dark {
${[...darkVars, ...componentVars].join('\n')}
  }
}
`;
  },
});

// Mobile用 tokens.ts format
StyleDictionary.registerFormat({
  name: 'typescript/mobile-tokens',
  format: () => {
    const tokens = loadTokens();
    const resolve = (v) => resolveReference(v, tokens.primitive.color);

    const colors = {
      primitive: buildNestedObject(tokens.primitive.color),
      light: buildNestedObject(tokens.semanticLight.color, resolve),
      dark: buildNestedObject(tokens.semanticDark.color, resolve),
      component: buildNestedObject(tokens.component, resolve),
      action: buildNestedObject(tokens.semanticAction, resolve),
    };

    const spacing = buildFlatObject(tokens.primitive.spacing);
    const radius = buildFlatObject(tokens.primitive.radius);
    // borderRadiusNum: React Native style属性用の数値版（"8px" → 8）
    const radiusNum = {};
    for (const [key, val] of Object.entries(radius)) {
      radiusNum[key] = parseInt(val, 10);
    }
    const fontFamily = buildFlatObject(tokens.primitive.font?.family);
    const fontSize = buildFlatObject(tokens.primitive.font?.size);
    // fontSizeNum: React Native style属性用の数値版（"12px" → 12）
    const fontSizeNum = {};
    for (const [key, val] of Object.entries(fontSize)) {
      fontSizeNum[key] = parseInt(val, 10);
    }
    const fontWeight = buildFlatObject(tokens.primitive.font?.weight);
    const lineHeight = buildFlatObject(tokens.primitive.font?.lineHeight);
    const letterSpacing = buildFlatObject(tokens.primitive.font?.letterSpacing);
    const duration = buildFlatObject(tokens.primitive.duration);
    const zIndex = buildFlatObject(tokens.primitive.zIndex);
    const iconSize = buildFlatObject(tokens.primitive.iconSize);

    const shadow = {};
    for (const [key, val] of Object.entries(tokens.primitive.shadow || {})) {
      if (val?.value) shadow[key] = val.value;
    }

    const fmt = (obj) => JSON.stringify(obj, null, 2);

    return `/**
 * Design Tokens - Auto-generated by Style Dictionary
 * Do not edit directly
 */

export const colors = ${fmt(colors)} as const;
export const spacing = ${fmt(spacing)} as const;
export const fontFamily = ${fmt(fontFamily)} as const;
export const fontSize = ${fmt(fontSize)} as const;
/** React Native style属性用の数値版 fontSize（"12px" → 12） */
export const fontSizeNum = ${fmt(fontSizeNum)} as const;
export const fontWeight = ${fmt(fontWeight)} as const;
export const lineHeight = ${fmt(lineHeight)} as const;
export const letterSpacing = ${fmt(letterSpacing)} as const;
export const borderRadius = ${fmt(radius)} as const;
/** React Native style属性用の数値版 borderRadius（"8px" → 8） */
export const borderRadiusNum = ${fmt(radiusNum)} as const;
export const shadow = ${fmt(shadow)} as const;
export const iconSize = ${fmt(iconSize)} as const;
export const zIndex = ${fmt(zIndex)} as const;
export const duration = ${fmt(duration)} as const;

export const theme = {
  colors,
  spacing,
  fontFamily,
  fontSize,
  fontSizeNum,
  fontWeight,
  lineHeight,
  letterSpacing,
  borderRadius,
  borderRadiusNum,
  shadow,
  iconSize,
  zIndex,
  duration,
} as const;

export type Theme = typeof theme;
export type Colors = typeof colors;
export type Spacing = typeof spacing;
`;
  },
});

// NativeWind用 themes.ts format
StyleDictionary.registerFormat({
  name: 'typescript/nativewind-themes',
  format: () => {
    const tokens = loadTokens();
    const resolve = (v) => hexToRgb(resolveReference(v, tokens.primitive.color));

    const buildVars = (obj, prefix = 'color') => {
      const vars = {};
      const process = (source, currentPrefix) => {
        for (const [key, val] of Object.entries(source)) {
          if (val?.value !== undefined) {
            vars[`--${currentPrefix}-${key}`] = resolve(val.value);
          } else if (val && typeof val === 'object') {
            process(val, `${currentPrefix}-${key}`);
          }
        }
      };
      process(obj, prefix);
      return vars;
    };

    const formatVars = (vars) =>
      Object.entries(vars)
        .sort(([a], [b]) => a.localeCompare(b))
        .map(([key, value]) => `  '${key}': '${value}',`)
        .join('\n');

    // action-*はテーマに依存しない固定色だが、CSS変数として両テーマに含める
    const actionVars = buildVars(tokens.semanticAction);

    return `/**
 * NativeWind テーマ定義 - Auto-generated by Style Dictionary
 * Do not edit directly
 */

import { vars } from 'nativewind';

export const lightTheme = vars({
${formatVars({ ...buildVars(tokens.semanticLight.color), ...actionVars })}
});

export const darkTheme = vars({
${formatVars({ ...buildVars(tokens.semanticDark.color), ...actionVars })}
});

export const themes = {
  light: lightTheme,
  dark: darkTheme,
} as const;

export type ThemeMode = keyof typeof themes;
`;
  },
});

// Storybook用 JSON format
StyleDictionary.registerFormat({
  name: 'json/storybook',
  format: () => {
    const tokens = loadTokens();
    const resolve = (v) => resolveReference(v, tokens.primitive.color);

    const result = {
      color: {
        primitive: buildNestedObject(tokens.primitive.color),
        semantic: {
          light: buildNestedObject(tokens.semanticLight.color, resolve),
          dark: buildNestedObject(tokens.semanticDark.color, resolve),
        },
        component: buildNestedObject(tokens.component, resolve),
        action: buildNestedObject(tokens.semanticAction, resolve),
      },
      spacing: buildFlatObject(tokens.primitive.spacing),
      radius: buildFlatObject(tokens.primitive.radius),
      font: buildNestedObject(tokens.primitive.font || {}),
    };

    return JSON.stringify(result, null, 2);
  },
});

// ============================================================
// エクスポート設定
// ============================================================

export default {
  source: ['tokens/primitive/*.json'],
  platforms: {
    mobile: {
      transformGroup: 'js',
      buildPath: 'build/mobile/',
      files: [
        { destination: 'tailwind-theme.js', format: 'javascript/tailwind-theme' },
        { destination: 'themes.ts', format: 'typescript/nativewind-themes' },
        { destination: 'tokens.ts', format: 'typescript/mobile-tokens' },
      ],
    },
    web: {
      transformGroup: 'css',
      buildPath: 'build/web/',
      files: [{ destination: 'tokens.css', format: 'css/variables-web' }],
    },
    storybook: {
      transformGroup: 'js',
      buildPath: 'build/storybook/',
      files: [{ destination: 'tokens.json', format: 'json/storybook' }],
    },
  },
};
