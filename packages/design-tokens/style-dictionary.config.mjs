/**
 * Style Dictionary Configuration
 *
 * デザイントークンを各プラットフォーム用に変換する設定
 * - Mobile: TypeScript + Tailwind theme object
 * - Web: CSS Variables
 * - Storybook: JSON (ドキュメント用)
 *
 * CTI命名規則（Category > Type > Item > State）に対応
 */

import StyleDictionary from 'style-dictionary';
import { readFileSync } from 'fs';
import { resolve, dirname } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));

// JSONファイルを直接読み込んでマージする
const loadTokens = () => {
  const primitiveColor = JSON.parse(readFileSync(resolve(__dirname, 'tokens/primitive/color.json'), 'utf-8'));
  const primitiveSpacing = JSON.parse(readFileSync(resolve(__dirname, 'tokens/primitive/spacing.json'), 'utf-8'));
  const primitiveTypography = JSON.parse(readFileSync(resolve(__dirname, 'tokens/primitive/typography.json'), 'utf-8'));
  const semanticLight = JSON.parse(readFileSync(resolve(__dirname, 'tokens/semantic/color.json'), 'utf-8'));
  const semanticDark = JSON.parse(readFileSync(resolve(__dirname, 'tokens/semantic/color-dark.json'), 'utf-8'));
  const spotColors = JSON.parse(readFileSync(resolve(__dirname, 'tokens/semantic/spot-colors.json'), 'utf-8'));

  return {
    primitive: {
      ...primitiveColor,
      ...primitiveSpacing,
      ...primitiveTypography,
    },
    semanticLight,
    semanticDark,
    spotColors,
  };
};

// トークン参照を解決する
// 例: "{color.gray.900}" → "#111827"
const resolveReference = (value, primitiveColor) => {
  if (typeof value !== 'string' || !value.startsWith('{')) return value;

  // {color.gray.900} → ["color", "gray", "900"]
  const refPath = value.slice(1, -1).split('.');

  // primitiveColorは既に"color"の中身なので、最初の"color"をスキップ
  let resolved = primitiveColor;
  const startIndex = refPath[0] === 'color' ? 1 : 0;

  for (let i = startIndex; i < refPath.length; i++) {
    const key = refPath[i];
    if (resolved && resolved[key]) {
      resolved = resolved[key];
    } else {
      return value; // 解決できなければ元の値を返す
    }
  }

  // 値オブジェクトの場合
  if (typeof resolved === 'object' && resolved.value) {
    return resolved.value;
  }

  return resolved;
};

// Mobile用 Tailwind theme format
StyleDictionary.registerFormat({
  name: 'javascript/tailwind-theme',
  format: () => {
    const tokens = loadTokens();
    const primitiveColor = tokens.primitive.color;

    // Primitiveカラーを構築
    const primitive = {};
    const buildPrimitive = (obj, prefix = []) => {
      for (const [key, val] of Object.entries(obj)) {
        if (val && typeof val === 'object' && val.value !== undefined) {
          // リーフノード
          let current = primitive;
          for (const p of prefix) {
            if (!current[p]) current[p] = {};
            current = current[p];
          }
          current[key] = val.value;
        } else if (val && typeof val === 'object') {
          // ネストノード
          buildPrimitive(val, [...prefix, key]);
        }
      }
    };
    buildPrimitive(primitiveColor);

    // Lightテーマカラーを構築
    const light = {};
    const buildSemantic = (obj, target, prefix = []) => {
      for (const [key, val] of Object.entries(obj)) {
        if (val && typeof val === 'object' && val.value !== undefined) {
          let current = target;
          for (const p of prefix) {
            if (!current[p]) current[p] = {};
            current = current[p];
          }
          current[key] = resolveReference(val.value, primitiveColor);
        } else if (val && typeof val === 'object') {
          buildSemantic(val, target, [...prefix, key]);
        }
      }
    };
    buildSemantic(tokens.semanticLight.color, light);

    // Darkテーマカラーを構築
    const dark = {};
    buildSemantic(tokens.semanticDark.color, dark);

    // Spotカラーを追加
    const spotTransport = {};
    buildSemantic(tokens.spotColors.color, spotTransport);

    // light/darkにspotとtransportをマージ
    Object.assign(light, spotTransport);
    Object.assign(dark, spotTransport);

    return `/**
 * Tailwind Theme Colors - Auto-generated by Style Dictionary
 * Do not edit directly
 *
 * CTI構造:
 * - primitive: ベースカラー（brand, gray等）
 * - light/dark: セマンティックカラー（text, background等）
 */

module.exports = {
  colors: {
    primitive: ${JSON.stringify(primitive, null, 2).replace(/\n/g, '\n    ')},
    light: ${JSON.stringify(light, null, 2).replace(/\n/g, '\n    ')},
    dark: ${JSON.stringify(dark, null, 2).replace(/\n/g, '\n    ')}
  }
};
`;
  },
});

// CSS Variables format (Web用)
StyleDictionary.registerFormat({
  name: 'css/variables-web',
  format: () => {
    const tokens = loadTokens();
    const primitiveColor = tokens.primitive.color;

    const lightVars = [];
    const darkVars = [];

    // Semanticカラーを処理
    const processColor = (obj, vars, prefix = []) => {
      for (const [key, val] of Object.entries(obj)) {
        if (val && typeof val === 'object' && val.value !== undefined) {
          const varName = [...prefix, key].join('-');
          const resolvedValue = resolveReference(val.value, primitiveColor);
          vars.push(`  --${varName}: ${resolvedValue};`);
        } else if (val && typeof val === 'object') {
          processColor(val, vars, [...prefix, key]);
        }
      }
    };

    processColor(tokens.semanticLight.color, lightVars);
    processColor(tokens.semanticDark.color, darkVars);
    processColor(tokens.spotColors.color, lightVars);

    lightVars.sort();
    darkVars.sort();

    return `/**
 * CSS Variables - Auto-generated by Style Dictionary
 * Do not edit directly
 *
 * CTI構造のセマンティックカラー:
 * - text-*, background-*, border-*, icon-*, action-*
 */

@layer base {
  :root {
${lightVars.join('\n')}
  }

  .dark {
${darkVars.join('\n')}
  }
}
`;
  },
});

// Storybook用 JSON format
StyleDictionary.registerFormat({
  name: 'json/storybook',
  format: () => {
    const tokens = loadTokens();
    const primitiveColor = tokens.primitive.color;

    const result = {
      color: {
        primitive: {},
        semantic: {
          light: {},
          dark: {},
        },
        spot: {},
        transport: {},
      },
      spacing: {},
      radius: {},
      font: {},
    };

    // Primitiveカラー
    const buildFlat = (obj, target, prefix = []) => {
      for (const [key, val] of Object.entries(obj)) {
        if (val && typeof val === 'object' && val.value !== undefined) {
          let current = target;
          for (const p of prefix) {
            if (!current[p]) current[p] = {};
            current = current[p];
          }
          current[key] = val.value;
        } else if (val && typeof val === 'object') {
          buildFlat(val, target, [...prefix, key]);
        }
      }
    };
    buildFlat(primitiveColor, result.color.primitive);

    // Semantic Light
    const buildSemantic = (obj, target, prefix = []) => {
      for (const [key, val] of Object.entries(obj)) {
        if (val && typeof val === 'object' && val.value !== undefined) {
          let current = target;
          for (const p of prefix) {
            if (!current[p]) current[p] = {};
            current = current[p];
          }
          current[key] = resolveReference(val.value, primitiveColor);
        } else if (val && typeof val === 'object') {
          buildSemantic(val, target, [...prefix, key]);
        }
      }
    };
    buildSemantic(tokens.semanticLight.color, result.color.semantic.light);
    buildSemantic(tokens.semanticDark.color, result.color.semantic.dark);

    // Spot & Transport
    if (tokens.spotColors.color.spot) {
      buildFlat({ spot: tokens.spotColors.color.spot }, { spot: result.color.spot });
      for (const [key, val] of Object.entries(tokens.spotColors.color.spot)) {
        if (val.value) result.color.spot[key] = val.value;
      }
    }
    if (tokens.spotColors.color.transport) {
      for (const [key, val] of Object.entries(tokens.spotColors.color.transport)) {
        if (val.value) result.color.transport[key] = val.value;
      }
    }

    // Spacing
    if (tokens.primitive.spacing) {
      for (const [key, val] of Object.entries(tokens.primitive.spacing)) {
        if (val.value) result.spacing[key] = val.value;
      }
    }

    // Radius
    if (tokens.primitive.radius) {
      for (const [key, val] of Object.entries(tokens.primitive.radius)) {
        if (val.value) result.radius[key] = val.value;
      }
    }

    // Font
    if (tokens.primitive.font) {
      buildFlat(tokens.primitive.font, result.font);
    }

    return JSON.stringify(result, null, 2);
  },
});

export default {
  source: ['tokens/primitive/*.json'], // ダミーソース（formatで直接読み込むため）
  platforms: {
    mobile: {
      transformGroup: 'js',
      buildPath: 'build/mobile/',
      files: [
        {
          destination: 'tailwind-theme.js',
          format: 'javascript/tailwind-theme',
        },
      ],
    },
    web: {
      transformGroup: 'css',
      buildPath: 'build/web/',
      files: [
        {
          destination: 'tokens.css',
          format: 'css/variables-web',
        },
      ],
    },
    storybook: {
      transformGroup: 'js',
      buildPath: 'build/storybook/',
      files: [
        {
          destination: 'tokens.json',
          format: 'json/storybook',
        },
      ],
    },
  },
};
